scls_osqp <- function(y, x, xnew = NULL) {
  
  py <- ncol(y)    ;    px <- ncol(x)
  pyx <- py * px   ;    n <- nrow(y)
  
  # Convert inputs to sparse if not already
  if ( !inherits(y, "sparseMatrix") )  y <- Matrix::Matrix(y, sparse = TRUE)
  if ( !inherits(x, "sparseMatrix") )  x <- Matrix::Matrix(x, sparse = TRUE)
  
  xx <- Matrix::crossprod(x)  # sparse
  xy <- Matrix::crossprod(x, y)  # sparse
  
  # Construct sparse P via Kronecker product
  P <- 2 * Matrix::kronecker(Matrix::Diagonal(py), xx)
  # q vector (usually dense, but keep efficient)
  q <- -2 * as.vector( as.matrix(xy) )
  # Constraints: l ≤ Aβ ≤ u
  # Equality: sum-to-one for each predictor
  A_eq <- Matrix::kronecker(Matrix::Diagonal(px), Matrix::Matrix(rep(1, py), nrow = 1, sparse = TRUE))
  # Inequality: non-negativity
  A_ineq <- Matrix::Diagonal(pyx)
  # Stack constraints (both sparse)
  A <- rbind(A_eq, A_ineq)
  l <- c(rep(1, px), rep(0, pyx))
  u <- c(rep(1, px), rep(Inf, pyx))
  # Solve with OSQP
  settings <- osqp::osqpSettings(verbose = FALSE, eps_abs = 1e-8, eps_rel = 1e-8)
  model <- osqp::osqp(P = P, q = q, A = A, l = l, u = u, pars = settings)
  res <- model$Solve()
  be <- matrix(res$x, ncol = py)
  #fitted <- x %*% be
  #mse <- sum( (as.matrix(y) - as.matrix(fitted))^2 ) / n
  mse <- ( model$Solve()$info$obj_val + sum(y^2) ) / n
  
  if (is.null(colnames(y))) {
    colnames(be) <- paste0("Y", 1:py)
  } else colnames(be) <- colnames(y)
  
  if (is.null(colnames(x))) {
    rownames(be) <- paste0("X", 1:px)
  } else rownames(be) <- colnames(x)
  
  est <- NULL
  if ( !is.null(xnew) ) {
    if (!inherits(xnew, "sparseMatrix")) {
      xnew <- Matrix::Matrix(xnew, sparse = TRUE)
    }
    est <- as.matrix(xnew %*% be)
  }
  
  list(mse = mse, be = be, est = est)
}